---
title: 'HHHH'
date: 2020-10-03
permalink: /posts/2010/10/blog-post-6/
tags:
  - Technology
  - SJTU_notes
  - DataBaseTechnology
---

2017-2018 SJTU SE305 数据库技术笔记


# 数据库系统概述

## Data 数据
数据是数据库中存储的基本对象，描述事物的符号记录称为数据。数据的含义成为数据的语义，数据与其语义是不可分的。
## DataBase数据库
数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。  

数据库的基本特征：

- 数据按一定的模型组织、描述和存储
- 可为各用户共享
- 冗余度较小
- 数据独立性较高

## DatabBase Management System数据库管理系统
DBMS与操作系统一样是计算机的基础软件（一个大型复杂的软件系统）

- 数据定义功能 DDL Data Definition Language
- 数据组织、存储和管理
- 数据操纵功能 DML Data Manipylation Language
- 数据库的事物管理和运行管理
- 数据库的建立与维护
- 其他功能

## DataBase System 数据库系统

数据库系统是由数据库、数据库管理系统、应用程序和数据库管理员（DataBase Administrator, DBA)组成的存储、管理、处理和维护数据的系统。  
与操作、管理数据相关的所有软硬件和人员的集合，主要包括：  

- 数据库
- 数据库管理系统DBMS
- 开发工具和应用系统
- 管理和使用数据库系统的人，特别是DBA(DataBase Administrator)
- 技术说明书/使用说明书

# 数据管理技术的产生和发展
## 人工管理阶段
- 数据不保存
- 应用程序管理数据
- 数据不共享（数据面向应用程序定义）
- 数据不具有独立性（数据的逻辑结构或者物理结构发生变化后，必须对应用程序做相应修改）

## 文件系统阶段
- 数据可以长期保存
- 由文件系统管理数据
- 数据共享性差、冗余度大（数据依然面向应用）
- 数据独立性差（不具有弹性的无整体结构的数据集合）

## 数据库系统阶段
- 数据结构化（数据库系统与文件系统的本质区别）
- 数据共享性高、冗余度低且易扩充
- 数据独立性高
   - 物理独立性：用户的应用程序与数据库中数据的物理存储相互独立。当数据的存储位置或存储结构发生变化时，不影响应用程序的特性。
   - 逻辑独立性：用户的应用程序与数据库的逻辑结构相互独立。例如，“学生数据库”中的某张表增加属性列，不会影响原应用程序的执行
- 数据由数据库管理系统统一管理和控制
   - security安全性
   - integrity完整性
   - concurrency并发控制
   - recovery数据库恢复

# 数据库发展简史
按照数据模型的进展情况，数据库系统的发展可划分为三代：

- 第一代：层次数据库系统和网状数据库系统
  
  主要支持层次和网状数据模型
- 第二代：关系数据库系统
          
 支持关系数据模型，该模型有严格的理论基础，概念简单、清晰，易于用户理解和使用
- 第三代：新一代数据库系统——面向对象数据库系统
  
   基于扩展的关系数据模型或面向对象数据模型的尚未完全成熟的一代数据库系统 
  
   特点：支持包括数据、对象和知识的管理
   
   产品：Object Store、Ontos、O2、Jasmin等
   
# 数据模型（3种）
数据模型是对现实世界数据特征的抽象，是数据库系统的核心和基础
 
现实世界->信息世界->机器世界

## 概念模型（信息模型）
* 按用户的观点来对数据和信息建模
* 主要用于数据库设计。
* 不依赖于具体的计算机系统
* 最常用的概念模型是E-R模型

### 信息世界的基本概念
- entity实体 
  - 客观存在并可相互区别的事物
- attribute属性
  -  实体所具有的某一特性
- key码 
   - 唯一标识实体的属性集
- entity type实体型 
  - 用实体名及属性名集合来抽象和刻画同类实体
 例如学生（学号，姓名，性别，出生年月，院系）就是一个实体型
- entity set实体集 
  - 同一类型实体的集合称为实体集，全体学生就是一个实体集
- relationship联系 
 - 实体内部的联系：各属性之间的联系
 - 实体之间的联系：不同实体集之间的联系
          - (1)  一对一联系（1：1）   系——系主任
          - (2)  一对多联系（1：n）   班级——学生
         -  (3)  多对多联系（m：n）   课程——学生

### 概念模型的表示方法（Entity-Relationship approach实体-联系方法）即（E-R diagram）E-R图





## 逻辑模型

- 数据库中不仅要存放数据本身，还要存放数据间的联系
- 可用不同的方法表示数据之间的联系
- 表示数据之间联系的方法称为逻辑（数据）模型
- 按计算机系统的观点对数据建模
- 主要用于DBMS的实现
- 有网状、层次、关系、面向对象等

- 非关系模型
  -  层次模型（Hierarchical Model）
  - 网状模型(Network Model )
- 关系模型(Relational Model)  
  - 数据结构：表
- 面向对象模型(Object Oriented Model）
  - 数据结构：对象

### 层次模型
![hierarchyModel](image/hierarchyModel.png)
![hierarchyModel](image/hierarchyModel2.png)
### 网状模型
![hierarchyModel](image/networkModel.png)
![hierarchyModel](image/networkModel2.png)


网状模型与层次模型的区别

* 网状模型允许多个结点没有双亲结点
* 网状模型允许结点有多个双亲结点
* 网状模型允许两个结点之间有多种联系（复合联系）
* 网状模型可以更直接地去描述现实世界
* 层次模型实际上是网状模型的一个特例

### 关系模型
![relationalModel](image/relationalModel.png)

- 关系（Relation）
一个关系对应一张表
- 元组（Tuple）
表中的一行即为一个元组
- 属性（Attribute）
   表中的一列即为一个属性，给每一个属性起一个名称即属性名
- 主码（Key）
表中的某(组)属性，它可以唯一确定一个元组。
- 域（Domain）
属性的取值范围

![relationalModel](image/relationalModel2.png)

关系模型的优缺点

- 优点
 - 建立在严格的数学概念的基础上
 - 概念单一
 - 实体和各类联系都用关系来表示
 - 对数据的检索结果也是关系
 - 关系模型的存取路径对用户透明
 - 具有更高的数据独立性，更好的安全保密性
 - 简化了程序员的工作和数据库开发建立的工作
- 缺点
 - 查询效率往往不如非关系数据模型





## 物理模型
- 反映数据的存储结构

# 数据库系统的结构
三级模式结构，是数据库系统内部的系统结构

## 数据库系统模式的概念
- “型”type 对某一类数据的结构和属性的说明
- 值value 值是型的一个具体赋值
- 模式schema 数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图，它仅仅涉及型的描述，不涉及具体的值。
- 实例instance 模式的一个具体值

### 数据库系统的三级模式结构
- 模式 
- 外模式external schema 外模式也称子模式或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，始于某一应用有关的数据的逻辑表示。外模式通常是模式的子集。
- 内模式internal schema内模式也称存储模式storage schema，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。

### 数据库的二级映像功能与数据独立性
- 外模式/模式映像（逻辑独立性）
- 模式/内模式映像（物理独立性）


## 关系
- 候选码：某一属性组的值能唯一的标识一个元组，而其子集不能，该属性组为候选码。（所有属性都是候选码，称为全码all-key）
- 主码：选定其中一个候选码作为主码
- 主属性：候选码的各属性
- 非主属性（非码属性）：不包含在任何候选码中的属性

关系的三种类型：基本关系（基本表）、查询表、视图表。


关系模式与关系的区别：  
关系模式：对关系的结构描述，静态的稳定的  
关系：关系模式在某一时刻的状态或内容 动态的 随时间变化的

### 关系数据操作
查询：选择、投影、连接、除、并、交、差  
五个基本操作：选择、投影、并、差、笛卡尔积

关系操作的特点是集合操作方式，操作的对象和结果都是集合set-at-a-time 非关系数据模型的数据操作方式则为一次一记录record-at-a-time

### 两种关系语言
关系代数语言：代数方式
关系演算语言：用谓词来表达查询要求-逻辑方式 关系元组演算语言ALPHA域关系演算语言QBE  
SQL：具有关系代数和关系演算双重特点的语言

### 关系的完整性
三类：实体完整性、参照完整性和用户定义的完整性

实体完整性和参照完整性:  
关系模型必须满足的完整性约束条件
用户定义的完整性：  
体现了具体应用领域中的语义约束

- 实体完整性规则：主属性不能取空值
- 参照完整性规则：外码值与被参照表中的主码值相对应或者取空值（如果外码不是其所在关系的主属性，则可以取空值）
- 用户定义的完整性：


### 关系代数
- 传统的集合运算：  
并交差： 要求属性同型  
笛卡尔积： 无条件连接，任意两个关系的信息都能连接在一起

- 专门的关系运算：
   - 投影 选择:一元运算
   - 连接 除:二元运算
   
## 关系模式、关系、关系数据库
- 关系模式：关系的描述称为关系模式  
- 关系：关系是关系模式在某一时刻的状态或内容
- 关系数据库：关系数据库也有型和值之分，关系数据库的型称为关系数据库模式，是对关系数据库的描述，它包括若干域的定义以及这些域上定义的若干关系模式。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库、

关系模式是型，关系是值，是关系模式的实例。

关系完备性是指一个查询语言能够表示关系代数可以表示的所有查询。
关系演算具有完备的表达能力。



# SQL

SQL功能：数据定义 数据操纵 数据控制  DDL DML DCL
SQL形式：交互式/嵌入式



索引属于内模式！！！！


UNIQUE表明此索引的每一个索引值只对应唯一的数据记录
CLUSTER表示要建立的索引是聚簇索引



# 索引
一个索引中包含指定列的所有值及其相应的存储位置

# 数据库安全性

## 安全基本要素
基本概念：

安全，低于可能的风险和威胁的能力，一般只关心由于人为因素所产生的风险和威胁。

威胁(threats):对安全的潜在破坏。这种破坏不一定等实际发生才构成威胁

攻击(attack):可能导致破坏的行为，发起人被称为攻击者

基本要素：Confidentiality/Integrity/Availability/Non-repudiation(不可抵赖性)/可审计性
 
## 数据库安全控制机制
- (基于口令的)用户鉴别(散列函数/OTP/智能卡/生物特征）
- 存取控制（包括自主存取控制 Discretionary Access Control DAC,强制存取控制 Mandatory Access Control MAC)
   - 用户权限定义
   - 权限检查机制

### 自助存取控制方法

- 授权GRANT 

GRANT <权限>[,<权限>]...  
ON <对象类型> <对象名>   
TO <用户>[,<用户>]...   
[WITH GRANT OPTION];


所有权限（ALL PREVILIGES）所有用户（PUBLIC）

- 权限回收revoke

REVOKE <权限>[,<权限>]...  
ON <对象类型> <对象名>   
FROM <用户>[,<用户>]...;

CASCADE级联收回

### 数据库角色
被命名的一组与数据库操作相关的权限

- 角色是权限的集合
- 可以为一组具有相同权限的用户创建一个角色

通过角色来实现将一组权限授予一个用户。 步骤如下:

1. 首先创建一个角色 R1 
`CREATE ROLE R1;`
2. 然后使用GRANT语句，使角色R1拥有Student表的SELECT、 UPDATE、INSERT权限
`GRANT SELECT，UPDATE，INSERT ON TABLE Student
TO R1;`
3. 将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的 全部权限
`GRANT R1
TO 王平，张明，赵玲;`
4. 可以一次性通过R1来回收王平的这3个权限
`REVOKE R1 FROM 王平;`

### 强制存取控制方法


- 主体是系统中的活动实体
  - DBMS所管理的实际用户 
  - 代表用户的各进程
- 客体是系统中受主体操纵的被动实体:文件、基表、索引、视图 
- 敏感度标记(Label)
  -  绝密(Top Secret) 
  -  机密(Secret)
  -  可信(Confidential) 
  -  公开(Public)
- 主体的敏感度标记称为许可证级别(Clearance Level) 
- 客体的敏感度标记称为密级(Classification Level)
- 强制存取控制规则
  - 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应
的客体
  - 仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体 (禁止了拥有高许可证级别的主体更新低密级的数据对象)

<mark>SQL语法分析&语义检查->DAC检查->MAC检查->继续语义检查</mark>


## 视图机制
把要保密的数据对无权存取这些数据的用户 隐藏起来，对数据提供一定程度的安全保护

## 审计

## 数据加密


# 数据库事务处理

## 事物概念
`BEGIN TRANSACTION;`  
`COMMIT;`  
`ROLLBACK`

事务是程序的逻辑运行单元

- 计算环境的脆弱性—故障恢复问题
- 计算环境的分布性—并发控制问题

ACID  

- Atomicity原子性 
  - 事务的所有操作要么完全执行, 要么全不做 
  - 由DBMS恢复机制实现
- <MARK>Consistency一致性
  - 事务执行必须保证数据库的一致性 
  - 数据库事务的目标
- <mark>Isolation隔离性
  - 每个事务感觉到都是在没有其它事务的情况下执行的
  - 事务不受其它并发执行事务的影响。对任何一对事务T1，T2，在 T1看来，T2要么在T1开始之前已经结束，要么在T1完成之后再 开始执行
  - 隔离性通过DBMS并发控制机制实现
- Durability持久性
  - 一旦事务提交， 事务对数据库的影响就不会丢失, 即使再发生系 统故障
  - 系统发生故障不能改变事务的结果 
  - 通过恢复机制实现

## 事物状态

Active/Partially committed/Failed/Aborted/Committed

## 原子性与持久性的实现
数据库系统的恢复管理(recovery-management ) 部件负责实现对原子性与持久性的支持  
shadow-database方案:

- 所有更新都是对数据库的一份影子拷贝(shadow copy) 进行的, 仅当事务到达部分提交状态并且所 有更新页都已写回磁盘，db_pointer 才指向更新 后的shadow copy.
- 如果事务失败, db_pointer所指向的旧的一致拷贝 仍可用, 而shadow copy 则被删除.
  
  
## 并发控制概述
并发操作带来的数据不一致性包括丢失修改、不可重复读和脏读。  

并发控制的主要技术：
- locking封锁（常用）
- timestamp时间戳
- 乐观控制发

调度（Schedule）：使并发事物的代码按时间顺序执行的序列

### 封锁（locking）
- X锁（exclusive locks)
- S锁（share locks）

- 一级封锁协议 X锁 可以防止‘丢失修改’，不能保证可重复读和脏读。
- 二级封锁协议 可以防止脏读
- 三级封锁协议

活锁：先来先服务  
死锁：预防/诊断与解除

### 并发调度的可串行性

#### 可串行化调度serializable
多个事务的并发执行是正确的，当且仅当其结果与某一次序串行地执行这些事务时的结果相同。  

冲突操作指不同的事务对同一个数据的读写操作和写写操作。

#### 冲突可串行化调度
可串行化调度的充分条件  
一个调度S在保证冲突操作的次序不变的情况下，通过交换两个事务不 冲突操作的次序得到另一个调度S’，如果S’是串行的，称调度S为冲 突可串行化的调度【二者冲突等价】

不能交换(Swap)的动作:
- 同一事务的两个操作
- 不同事务的冲突操作

### 两段锁协议
两段封锁协议(Two-Phase Locking，简称2PL)是最常用的一种封锁协议，理论上已证明使用两段封锁协议产生的是可串行化调度  
数据库管理系统普遍采用两段锁协议的方法实现并发调度 的可串行性，从而保证调度的正确性

两段锁协议:所有事务分两个阶段对数据项加锁和解锁

-  在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁
-  在释放一个封锁之后，事务不再申请和获得任何其他封锁

 “两段”锁的含义:  

- 第一阶段是获得封锁，也称为扩展阶段
    - 事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁
- 第二阶段是释放封锁，也称为收缩阶段
    - 事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。  

  
事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件


两段锁协议与防止死锁的一次封锁法

- 一次封锁法要求每个事务必须一次将所有要使用的数 据全部加锁，否则就不能继续执行，因此一次封锁法 遵守两段锁协议
- 但是两段锁协议并不要求事务必须一次将所有要使用 的数据全部加锁，因此遵守两段锁协议的事务可能发 生死锁

### 封锁粒度
封锁对象的大小称为封锁粒度(Granularity)  

封锁的对象: 逻辑单元，物理单元    
例:在关系数据库中，封锁对象:

- 逻辑单元: 属性值、属性值的集合、元组、关系、索引 项、整个索引、整个数据库等
- 物理单元:页(数据页或索引页)、物理记录等


封锁粒度与系统的并发度和并发控制的开销密切相关

- 封锁的粒度越大，数据库所能够封锁的数据单元就越
少，并发度就越小，系统开销也越小;
- 封锁的粒度越小，并发度较高，但系统开销也就越大

  
多粒度封锁(Multiple Granularity Locking)  
在一个系统中同时支持多种封锁粒度供不同的事务
选择

- 需要处理多个关系的大量元组的用户事务:以数据库为封锁单位
- 需要处理大量元组的用户事务:以关系为封锁单元 
- 只处理少量元组的用户事务:以元组为封锁单位

多粒度树  
显式封锁和隐式封锁
