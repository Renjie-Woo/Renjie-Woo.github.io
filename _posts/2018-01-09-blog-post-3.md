---
title: 'è®¡ç®—ç†è®ºã®å¤ä¹ '
date: 2018-01-09
permalink: /posts/2014/08/blog-post-3/
tags:
  - Theory of Computation
  - SJTU_Notes
---

Review of *Theory of Computation* 

# è®¡ç®—ç†è®ºã®å¤ä¹ 



## chapter1 è‡ªåŠ¨æœºä¸è¯­è¨€

### **æœ‰ç©·è‡ªåŠ¨æœºï¼ˆç¡®å®šå‹/éç¡®å®šå‹ï¼‰ â€”  regular languageæ­£åˆ™è¯­è¨€**

*æœ‰ç©·è‡ªåŠ¨æœºæ˜¯ç”¨çŠ¶æ€å›¾è¡¨ç¤ºå“’ï¼ finite memory*  
An FA has three **components**:  1. input tape contains single string;  2. head reads input string one symbol at a time; and  3. Memory is in one of a finite number of states.

**Operating an FA.**   1) Set the machine to start state.  2) If End-of-String then halt.  3) Read a symbol.  4) Update state according to current state and symbol read.  5) Goto Step 2.

finite states---->finite memory

**å°é—­æ€§** æ­£åˆ™è¯­è¨€åœ¨union/concatenation/Kleene_star/è¡¥/äº¤å°é—­

**æ­£åˆ™è¡¨è¾¾å¼**regular expressionï¼šæ­£åˆ™è¡¨è¾¾å¼çš„å€¼æ˜¯ä¸€ä¸ªè¯­è¨€

- ä¸è¦æ··æ·†æ­£åˆ™è¡¨è¾¾å¼ ğ“” å’Œ âˆ…ï¼Œè¡¨è¾¾å¼ğ“”è¡¨ç¤ºåªåŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²â€”ç©ºä¸²çš„è¯­è¨€ï¼Œè€Œâˆ…è¡¨ç¤ºä¸åŒ…å«ä»»ä½•å­—ç¬¦ä¸²çš„è¯­è¨€ã€‚

- å°†æƒ³è¦æ˜æ˜¾çš„åŒºåˆ†æ­£åˆ™è¡¨è¾¾å¼Rå’Œå®ƒæ‰€æè¿°çš„è¯­è¨€æ—¶ï¼Œå°†Ræè¿°çš„è¯­è¨€å†™æˆLï¼ˆRï¼‰ã€‚
- ç©ºé›†è¿ç»“åˆ°ä»»ä½•é›†åˆä¸Šéƒ½æ˜¯ç©ºé›†ï¼Œå› ä¸ºç©ºé›†æ²¡æœ‰ä»»ä½•å­—ç¬¦ä¸²å¯ä»¥ä¸ç¬¬ä¸€ä¸ªå­—ç¬¦ç›¸è¿ç»“

-------------------------
- è¯æ˜RLï¼Œç»™å‡ºæè¿°å®ƒçš„æ­£åˆ™è¡¨è¾¾å¼æˆ–è€…ç»™å‡ºrecognizeå®ƒçš„FA
- è¯æ˜CFLï¼Œç»™å‡ºä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æˆ–è€…ç»™å‡ºè¯†åˆ«å®ƒçš„ä¸‹æ¨è‡ªåŠ¨æœºã€‚
- è¯æ˜ä¸æ˜¯ pumping lemma

A language is regular if and only if some regular expression describes it.

### ä¸‹æ¨è‡ªåŠ¨æœº â€”â€”â€” context free language 
- A PDA is an FA together with a stack.  - A pushdown automaton (PDA) has a fixed set of states (like FA), but it also has one unbounded stack for storage.
- ==By definition, a PDA is nondeterministic.==It accepts the input string if there exists a sequence of actions leading to the accept state.

A pushdown automaton (PDA) has a fixed set of states (like FA), but it also has one unbounded stack for storage.  When symbol is read, depending on (a) state of automaton, (b) symbol on top of stack, and (c) symbol read, the automaton  1. updates its state, and  2. (optionally) pops or pushes a symbol.  The automaton may also pop or push without reading input.

#### chomsky normal form 
ä»»ä½•ä¸€ä¸ªCFLéƒ½å¯ä»¥ç”¨Chomsky normal formçš„CFGäº§ç”Ÿ

- è¯æ˜ä¸æ˜¯ pumping lemma


## chapter2 å¯è®¡ç®—ç†è®º

### The Church-Turing Thesis

 
æœ¬ç« ç ”ç©¶ç®—æ³•æ±‚è§£é—®é¢˜çš„èƒ½åŠ›ï¼Œæœ‰äº›é—®é¢˜ç®—æ³•ä¸Šèƒ½å¤Ÿæ±‚è§£ï¼Œå¦ä¸€äº›ä¸èƒ½ã€‚

 turing-recognizable å¯¹è¡¥ä¸å°é—­ï¼Œå¯¹äº¤/å¹¶å°é—­
 
 
## chapter4 å¯åˆ¤å®šæ€§

- Decidable Languages- Undecidability     - The diagonalization method


ADFA is a decidable language: Simulate B on input w. If the simulation ends in an accepting state, then accept. If it ends in a nonaccepting state, then reject.å¤„ç†å®Œwæœ€åä¸€ä¸ªç¬¦å·æ—¶æ¥å—åˆ™æ¥å—ã€‚
  
ANFA is a decidable languageï¼šé¦–å…ˆç”¨Convert NFA B to an equivalent DFA C using the subset construction. Then run M from ADFA decider.

AREX is a decidable language: Convert R to an equivalent NFA A. Run TM N from the previous Theorem on input. If N accepts, then accept; otherwise reject.

EDFA is a decidable language: è½¬ç§»æ ‡è®°

EQDFA is a decidable languageï¼šå¯¹ç§°å·®

ACFG is a decidable languageï¼šchomskyèŒƒå¼ï¼Œæ£€æŸ¥æœ‰é™ä¸ª

ECFG is a decidable languageï¼š
CFLåœ¨è¡¥å’Œäº¤ä¸å°é—­
EQCFG is a undecidable language

Every context-free language is decidable.

ATM ä¸å¯åˆ¤å®šï¼ˆåœæœºé—®é¢˜ï¼Œæ— æ³•çŸ¥é“æ˜¯å¦è¿›å…¥å¾ªç¯ï¼‰ å³æ£€æŸ¥ä¸€ä¸ªå›¾çµæœºæ˜¯å¦æ¥å—ä¸€ä¸ªç»™å®šä¸²çš„é—®é¢˜ã€‚

### å¯¹è§’åŒ–æ–¹æ³•ï¼š
æµ‹é‡æ— é™é›†åˆçš„è§„æ¨¡é—®é¢˜ã€‚ä¸€å¯¹ä¸€æ˜ å°„&æ»¡æ˜ å°„=ç›¸åŒè§„æ¨¡ one-to-one & onto 

Cantorâ€™s Theorem
A is countable if it is either finite or has the same size as N.

Qæ­£æœ‰ç†æ•°é›†åˆå¯æ•°

R is not countable.

------ 
æœ‰å¯æ•°ä¸ªå›¾çµæœºï¼Œå´æœ‰ä¸å¯æ•°ä¸ªè¯­è¨€ã€‚å› æ­¤å­˜åœ¨å›¾çµä¸å¯è¯†åˆ«çš„è¯­è¨€ã€‚

- å¯¹ä»»æ„çš„å­—æ¯è¡¨ï¼Œå…¶ä¸Šæ‰€æœ‰ä¸²çš„é›†åˆæ˜¯å¯æ•°çš„ã€‚
- æ¯ä¸ªå›¾çµæœºéƒ½æœ‰ä¸€ä¸ªç¼–ç ï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸²ã€‚
- æ— é™äºŒè¿›åˆ¶åºåˆ—æ„æˆçš„é›†åˆæ˜¯ä¸å¯æ•°çš„ã€‚
- å­—æ¯è¡¨ä¸Šæ‰€æœ‰è¯­è¨€çš„é›†åˆå¯¹åº”äºæ— é™äºŒè¿›åˆ¶åºåˆ—æ„æˆçš„é›†åˆã€‚

å¯¹è§’åŒ–è¯æ˜ATMä¸å¯åˆ¤å®šï¼š
  
- å‡è®¾ATMå¯åˆ¤å®šï¼Œè®¾Hæ˜¯ATMçš„åˆ¤å®šå™¨  
- Hçš„è¾“å…¥ä¸º\<M,w> åˆ¤å®šMæ˜¯å¦æ¥å—w  
- åœ¨HåŸºç¡€ä¸Šæ„é€ Dï¼ŒDçš„è¾“å…¥ä¸ºsomeTM Mçš„descriptionï¼ŒHå¯¹\<M,\<M>>è¿è¡Œï¼ŒDæ¥å—å½“ä¸”ä»…å½“Mæ‹’ç»\<M>.  
- Dæ¥å—\<D>å½“ä¸”ä»…å½“Dæ‹’æ¥\<D>  

ATMå›¾çµå¯è¯†åˆ«ï¼Œä¸å¯åˆ¤å®šã€‚ä¸æ˜¯co-Turing-recognizableã€‚

### ä¸€ä¸ªå›¾çµä¸å¯è¯†åˆ«è¯­è¨€

A language is co-Turing-recognizable if it is the complement of a Turing-recognizable lanugage.ï¼ˆå®ƒçš„è¡¥æ˜¯å›¾çµå¯è¯†åˆ«çš„ï¼‰

ä¸€ä¸ªè¯­è¨€æ˜¯å›¾çµå¯åˆ¤å®šçš„<==>å›¾çµå¯è¯†åˆ«&è¡¥å›¾çµå¯è¯†åˆ«

å›¾çµå¯è¯†åˆ«ï¼šä¸€ä¸ªè¯­è¨€èƒ½è¢«æŸä¸ªå›¾çµæœºè¯†åˆ«ï¼ˆæ¥å—ï¼‰ã€‚  
å›¾çµå¯åˆ¤å®šï¼šä¸€ä¸ªè¯­è¨€èƒ½è¢«æŸä¸ªå›¾çµæœºåˆ¤å®šã€‚ï¼ˆåˆ¤å®šå™¨æ˜¯æ°¸ä¸å¾ªç¯çš„å›¾çµæœºï¼‰

*a language is recognizable if you can think of a machine that'd be able to accept all its strings.*


## Chapter5 å¯å½’çº¦æ€§
ç”¨æ¥è¯æ˜é—®é¢˜æ˜¯è®¡ç®—ä¸Šä¸å¯è§£çš„ã€‚

###HALT_TM undecidableï¼š  
S = "on input\<M,w>,   
Run R on input M, if R reject,reject.   
if R accept, run M on input w,accept,accept. M reject,reject.

### E_TM undecidable:  
reducing ATM to ETM.  
construct M1 which will always accept empty language unless M accept w. then run E\_TM decider on M1, accept, reject. reject, accept.  
M1 on input x:  1. if x ä¸ç­‰äº w, then reject.  2. ifx=w, run M on w and accept if M does.  

S="on input\<M,w>:   
1.Use the description of M and w to construct the TM M1.  
2.Run R on input <M1>.  
3.If R accepts, then accept; if R rejects, then reject."  
**M1å¦‚æœåœ¨wä¸Šè¿›å…¥å¾ªç¯ï¼ŒM1è¯†åˆ«çš„ä»ç„¶æ˜¯ç©ºè¯­è¨€ï¼Œèƒ½è¢«E-TMåˆ¤å®šã€‚**

### REGULAR-TM undecidable  
reduce ATM to REGULAR-TM  
construct M2 which accept a regular language when M accept w and accept non-regular language when M dont accept w.  
**sigma star is a regular language.**  
M2 on input x:  1. If x has the form 0n1n, then accept.  2. Otherwise, run M on w and accept if M does.  

S ="on input \<M, w>:  1. Use the description of M and w to construct the TM M2.   
2. Run R on input <M2>.  3. If R accepts, then accept; if R rejects, then reject."


### EQ-TM is undecidable
å½’çº¦åˆ°ETM  
S='on input \<M>:  
1.Run R(EQ-TM) on input <M,M1>, where M1 is a Turing Machine that rejects all inputs.    
2.If R accepts, then accept; if R rejects, then reject.  

###Reductions via computation historiesåˆ©ç”¨è®¡ç®—å†å²çš„è§„çº¦
LBA linear bounded automoaton is undecidable
æœ‰é™å­˜å‚¨å›¾çµæœº

ADFA ACFG EDFA ECFGçš„åˆ¤å®šå™¨éƒ½æ˜¯LBA, æ¯ä¸ªCFLéƒ½å¯ç”±ä¸€ä¸ªLBAæ¥åˆ¤å®šã€‚

####ALBA is decidable.
**lemma**  
Let M be an LBA with q states and g symbols in the tape alphabet. There are exactly qng^n distinct configurations of M for a tape length n.  
**proof**  
L = "on input \<M,w>:  
1.Run M on w until it halts or for qng^n steps.  
2.if M has halted, accept if it has accepted and reject if it has rejected. if it has not halted, reject.

####ELBA is undecidable.
key pointï¼šé€šè¿‡TM Må’Œwæ„é€ LBA(B), Mæ¥å—wæ—¶ï¼ŒL(B)éç©ºã€‚Mæ‹’ç»wæ—¶ï¼ŒL(B)ç©ºã€‚  
 *L(B)ä¸ºç©ºæ—¶ï¼ŒMåœ¨wä¸Šæ²¡æœ‰accepting computation historyã€‚*

B = on input x(computation history):   
1. breaks up x according to the delimiters # into strings C1,...,Cl;    
2. determines whether ci satisfy:    
---1. C1 is the start configuration for M on w;   
---2. each Ci+1 legally follows from Ci;  
---3. Cl is an accepting configuration.  

	
S = on input \<M, w>:  1. Construct LBA B from M and w.  2. Run R on input \<B>.   3. If R rejects, then accept; if R accepts, then reject.  


####ALLCFG is undecidable.(æµ‹å®šä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æ˜¯å¦æ´¾ç”Ÿæ‰€æœ‰å¯èƒ½çš„ä¸²)
key point:  

- é€šè¿‡TM Må’Œwæ„é€ CFG Gï¼ŒMæ¥å—wæ—¶ï¼ŒGæ´¾ç”Ÿé™¤äº†wä¹‹å¤–çš„æ‰€æœ‰ä¸²ï¼ŒMä¸æ¥å—wæ—¶ï¼ŒGæ´¾ç”Ÿæ‰€æœ‰ä¸²ã€‚
- æ„é€ PDAæ¯”è¾ƒæ–¹ä¾¿ï¼Œä¸”equal toæ„é€ CFG
- Fact. Given a deterministic TM M, one can build a deterministic PDA that accepts the following language: {c1R#c2 : c1,c2 are configurations of M such that c2 follows from c1 }.

Then, G generates all strings  1. that do not start with C1,  2. that do not end with an accepting configuration, or  3. in which Ci does not properly yield Ci+1 under the rule of M.

We construct a PDA D and then convert it to G.  1. D starts by nondeterministically branching to guess whichof the three conditions to check.  2. The first and the second are straightforward.  3. The third branch accepts if some Ci does not properly yieldCi+1 . 
 1.  It scans the input and nondeterministically decides that ithas come to Cj.  2. It pushes Ci onto the stack until it reads #.  3. Then D pops the stack to compare with Ci+1: they are  almost the same except that around the head position, where the difference is dictated by the transition function of M.  4. D accepts if there is a mismatch or an improper update.

Altered Computation Strings  
For âŸ¨M,wâŸ©, define language of altered computa- tion strings:NM,w = {c1#cR2 #c3#cR4 #...#ck }

### Mapping Reducibility

#### Computable functions
A function f: Î£âˆ—âˆ’â†’Î£âˆ— is a computable function if some Turing machine M , on every input w, halts with just f (w) on its tape.
#### FORMAL DEFINITION OF MAPPING REDUCIBILITY
Language A is mapping reducible to language B, written A â‰¤m B,if there is a computable function f : Î£âˆ—âˆ’â†’Î£âˆ—, where for every w, w âˆˆ A â‡â‡’ f ( w ) âˆˆ B .The function f is called the reduction from A to B.

**If A â‰¤m B and B is decidable, then A is decidable.**  
**PROOF**   
We let M be the decider for B and f be the reduction from A to B.  We describe a decider N for A as follows.  N = â€œOn input w:  1. Compute f (w).  2. Run M on input f (w) and output whatever M outputs.â€  

==main tool for proving undecidability.==  
**If A â‰¤m B and A is undecidable, then B is undecidable.**

**HALT_TM is undecidable.**  
construct a mapping reducibility from ATM to HALT_TM as follows:  
present a computable function f that takes input of the form âŸ¨M,wâŸ© and returns output of the form âŸ¨Mâ€²,wâ€²âŸ©, whereâŸ¨M,wâŸ© âˆˆ ATM if and only if âŸ¨Mâ€²,wâ€²âŸ© âˆˆ HALTTM.

The following machine F computes a reduction f .  F = â€œOn input âŸ¨M, wâŸ©:  1. Construct the following machine M â€² .  Mâ€² = â€œOn input x:  1. Run M on x.  --2. If M accepts, accept.  --3. If M rejects, enter a loop.â€   
2. OutputâŸ¨Mâ€²,wâŸ©.â€  

E\_TM å½’çº¦åˆ°EQ\_TM, E\_TM is undecidable==>EQ\_TM is undecidable.  
the reductionf maps the input âŸ¨MâŸ© to the output âŸ¨M,M1âŸ©, where M1 is the machine that rejects all inputs.

E-TM is undecidable.  
f is a mapping reduction from ATM to ETM'complement.  

E-TM is recognizable. 

==prove nonrecognizability of certain languages==  
#### theorem   
**If A â‰¤m B and B is Turing-recognizable, then A is Turing-recognizable.**

**If A â‰¤m B and A is not Turing-recognizable, then B is not Turing-recognizable.**

**EQ_TM is neither Turing-recognizable nor co-Turing-recognizable.**  
ATM many-one reducible to EQTM.  
ATM many-one reducible to EQTM'C.


## chapter7 time complexity

big-O-notation ä¸å¤§äº  
small-O-notation å°äº

{0^n1^n}---O(n log n).

**any language that can be decided in o(nlogn) time on a single-tape Turing machine is regular.**

**Let t(n) be a function, where t(n) â‰¥ n. Then every t(n) time multitape Turing machine has an equivalent O(t^2(n)) time single-tape Turing machine.**

a nondeterministic Turing machine is a decider if all its computation branches halt on all inputs.(æ¯ä¸€ä¸ªåˆ†æ”¯éƒ½åœæœºçš„NTM)

**Let t(n) be a function, where t(n) â‰¥ n. Then every t(n) time nondeterministic single-tape Turing machine has an equivalent 2^O(t(n)) time deterministic single-tape Turing machine.**


PATH æ˜¯Pé—®é¢˜
RELPRIME æ˜¯Pé—®é¢˜ï¼ˆæ¬§å‡ é‡Œå¾—ï¼‰
æ¯ä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³è¯­è¨€éƒ½æ˜¯Pçš„æˆå‘˜ï¼ˆåŠ¨æ€è§„åˆ’ï¼‰

HAMPATH æ˜¯NP
COMPOSITES æ˜¯NP 

NPæ˜¯å…·æœ‰å¤šé¡¹å¼æ—¶é—´éªŒè¯æœºçš„è¯­è¨€ç±»ã€‚
ä¸€ä¸ªè¯­è¨€åœ¨NPä¸­ï¼Œå½“ä¸”ä»…å½“ä»–èƒ½è¢«è½¬åŒ–ä¸ºç­‰ä»·çš„å¤šé¡¹å¼æ—¶é—´NTMã€‚

CLIQUE å±äºNP
SUBSET-SUM å±äºNP

Cook-Levinå®šç†ï¼šSAT âˆˆ P iff P = NP.ï¼ˆSAT is NP-completeï¼‰

å¤šé¡¹å¼æ—¶é—´å¯è®¡ç®—&å¤šé¡¹å¼æ—¶é—´æ˜ å°„å¯å½’çº¦

IfAâ‰¤P B and BâˆˆP,then AâˆˆP

3SAT is polynomial time reducible to CLIQUE.
å°†å«æœ‰kä¸ªå­å¥çš„3nfå…¬å¼å½’çº¦åˆ°å­—ç¬¦ä¸²<G,k>.è§£æ— å‘å›¾ä¸­çš„kå›¢é—®é¢˜ã€‚

==**PROOF** of  SAT is NPC==   
SAT is in NP, since a nondeterministic polynomial time Turing machine can  1. guess an assignment to a given formula Ï†,  
2. accept if the assignment satisfies Ï†.

è¯æ˜NPä¸­çš„ä»»æ„è¯­è¨€Aå¯ä»¥å¤šé¡¹å¼å½’çº¦åˆ°SAT

3SAT å¤šé¡¹å¼æ—¶é—´å½’çº¦åˆ°VERTEX-COVER  
3SAT å¤šé¡¹å¼æ—¶é—´å½’çº¦åˆ°HAMPATH  
3SAT å¤šé¡¹å¼æ—¶é—´å½’çº¦åˆ°UHAMPAH  
3SAT å¤šé¡¹å¼å½’çº¦åˆ°SUBSET-SUM
